{"ast":null,"code":"import _classCallCheck from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _isNativeReflectConstruct from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport _getPrototypeOf from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\n\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\n\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport var ReplaySubject = /*#__PURE__*/function (_Subject) {\n  function ReplaySubject() {\n    var _this;\n\n    var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n    var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    var scheduler = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ReplaySubject);\n\n    _this = _callSuper(this, ReplaySubject);\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  _inherits(ReplaySubject, _Subject);\n\n  return _createClass(ReplaySubject, [{\n    key: \"nextInfiniteTimeWindow\",\n    value: function nextInfiniteTimeWindow(value) {\n      if (!this.isStopped) {\n        var _events = this._events;\n\n        _events.push(value);\n\n        if (_events.length > this._bufferSize) {\n          _events.shift();\n        }\n      }\n\n      _superPropGet(ReplaySubject, \"next\", this, 3)([value]);\n    }\n  }, {\n    key: \"nextTimeWindow\",\n    value: function nextTimeWindow(value) {\n      if (!this.isStopped) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n\n        this._trimBufferThenGetEvents();\n      }\n\n      _superPropGet(ReplaySubject, \"next\", this, 3)([value]);\n    }\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n      var scheduler = this.scheduler;\n      var len = _events.length;\n      var subscription;\n\n      if (this.closed) {\n        throw new ObjectUnsubscribedError();\n      } else if (this.isStopped || this.hasError) {\n        subscription = Subscription.EMPTY;\n      } else {\n        this.observers.push(subscriber);\n        subscription = new SubjectSubscription(this, subscriber);\n      }\n\n      if (scheduler) {\n        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n      }\n\n      if (_infiniteTimeWindow) {\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n          subscriber.next(_events[i]);\n        }\n      } else {\n        for (var _i = 0; _i < len && !subscriber.closed; _i++) {\n          subscriber.next(_events[_i].value);\n        }\n      }\n\n      if (this.hasError) {\n        subscriber.error(this.thrownError);\n      } else if (this.isStopped) {\n        subscriber.complete();\n      }\n\n      return subscription;\n    }\n  }, {\n    key: \"_getNow\",\n    value: function _getNow() {\n      return (this.scheduler || queue).now();\n    }\n  }, {\n    key: \"_trimBufferThenGetEvents\",\n    value: function _trimBufferThenGetEvents() {\n      var now = this._getNow();\n\n      var _bufferSize = this._bufferSize;\n      var _windowTime = this._windowTime;\n      var _events = this._events;\n      var eventsCount = _events.length;\n      var spliceCount = 0;\n\n      while (spliceCount < eventsCount) {\n        if (now - _events[spliceCount].time < _windowTime) {\n          break;\n        }\n\n        spliceCount++;\n      }\n\n      if (eventsCount > _bufferSize) {\n        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n      }\n\n      if (spliceCount > 0) {\n        _events.splice(0, spliceCount);\n      }\n\n      return _events;\n    }\n  }]);\n}(Subject);\n\nvar ReplayEvent = /*#__PURE__*/_createClass(function ReplayEvent(time, value) {\n  _classCallCheck(this, ReplayEvent);\n\n  this.time = time;\n  this.value = value;\n}); //# sourceMappingURL=ReplaySubject.js.map","map":{"version":3,"sources":["C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/rxjs/_esm2015/internal/ReplaySubject.js"],"names":["Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","SubjectSubscription","ReplaySubject","bufferSize","Number","POSITIVE_INFINITY","windowTime","scheduler","_events","_infiniteTimeWindow","_bufferSize","_windowTime","next","nextInfiniteTimeWindow","nextTimeWindow","value","isStopped","push","length","shift","ReplayEvent","_getNow","_trimBufferThenGetEvents","_subscribe","subscriber","len","subscription","closed","hasError","EMPTY","observers","add","i","error","thrownError","complete","now","eventsCount","spliceCount","time","Math","max","splice"],"mappings":"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","sourcesContent":["import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        if (!this.isStopped) {\n            const _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map"]},"metadata":{},"sourceType":"module"}