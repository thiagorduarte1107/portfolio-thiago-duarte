{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bound');\n\nvar inspect = require('object-inspect');\n\nvar getSideChannelMap = require('side-channel-map');\n\nvar $TypeError = require('es-errors/type');\n\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */\n\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */\n\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\n\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\n\nvar $weakMapDelete = callBound('WeakMap.prototype.delete', true);\n/** @type {import('.')} */\n\nmodule.exports = $WeakMap ?\n/** @type {Exclude<import('.'), false>} */\nfunction getSideChannelWeakMap() {\n  /** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */\n\n  /** @typedef {Parameters<Channel['get']>[0]} K */\n\n  /** @typedef {Parameters<Channel['set']>[1]} V */\n\n  /** @type {WeakMap<K & object, V> | undefined} */\n  var $wm;\n  /** @type {Channel | undefined} */\n\n  var $m;\n  /** @type {Channel} */\n\n  var channel = {\n    assert: function assert(key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    'delete': function _delete(key) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapDelete($wm, key);\n        }\n      } else if (getSideChannelMap) {\n        if ($m) {\n          return $m['delete'](key);\n        }\n      }\n\n      return false;\n    },\n    get: function get(key) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapGet($wm, key);\n        }\n      }\n\n      return $m && $m.get(key);\n    },\n    has: function has(key) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapHas($wm, key);\n        }\n      }\n\n      return !!$m && $m.has(key);\n    },\n    set: function set(key, value) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if (!$wm) {\n          $wm = new $WeakMap();\n        }\n\n        $weakMapSet($wm, key, value);\n      } else if (getSideChannelMap) {\n        if (!$m) {\n          $m = getSideChannelMap();\n        } // eslint-disable-next-line no-extra-parens\n\n        /** @type {NonNullable<typeof $m>} */\n\n\n        $m.set(key, value);\n      }\n    }\n  }; // @ts-expect-error TODO: figure out why this is erroring\n\n  return channel;\n} : getSideChannelMap;","map":{"version":3,"sources":["C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/side-channel-weakmap/index.js"],"names":["GetIntrinsic","require","callBound","inspect","getSideChannelMap","$TypeError","$WeakMap","$weakMapGet","$weakMapSet","$weakMapHas","$weakMapDelete","module","exports","getSideChannelWeakMap","$wm","$m","channel","assert","key","has","get","set","value"],"mappings":"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","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\nvar inspect = require('object-inspect');\nvar getSideChannelMap = require('side-channel-map');\n\nvar $TypeError = require('es-errors/type');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\n\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\n/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */\nvar $weakMapDelete = callBound('WeakMap.prototype.delete', true);\n\n/** @type {import('.')} */\nmodule.exports = $WeakMap\n\t? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {\n\t\t/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */\n\t\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t\t/** @type {WeakMap<K & object, V> | undefined} */ var $wm;\n\t\t/** @type {Channel | undefined} */ var $m;\n\n\t\t/** @type {Channel} */\n\t\tvar channel = {\n\t\t\tassert: function (key) {\n\t\t\t\tif (!channel.has(key)) {\n\t\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t\t}\n\t\t\t},\n\t\t\t'delete': function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapDelete($wm, key);\n\t\t\t\t\t}\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif ($m) {\n\t\t\t\t\t\treturn $m['delete'](key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tget: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $m && $m.get(key);\n\t\t\t},\n\t\t\thas: function (key) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif ($wm) {\n\t\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!$m && $m.has(key);\n\t\t\t},\n\t\t\tset: function (key, value) {\n\t\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\t\tif (!$wm) {\n\t\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t\t}\n\t\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t\t} else if (getSideChannelMap) {\n\t\t\t\t\tif (!$m) {\n\t\t\t\t\t\t$m = getSideChannelMap();\n\t\t\t\t\t}\n\t\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\t/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// @ts-expect-error TODO: figure out why this is erroring\n\t\treturn channel;\n\t}\n\t: getSideChannelMap;\n"]},"metadata":{},"sourceType":"script"}