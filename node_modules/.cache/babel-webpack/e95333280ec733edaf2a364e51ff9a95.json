{"ast":null,"code":"/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define.amd) {\n    define(definition);\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = definition();\n  } else {\n    root.log = definition();\n  }\n})(this, function () {\n  \"use strict\"; // Slightly dubious tricks to cut down minimized file size\n\n  var noop = function noop() {};\n\n  var undefinedType = \"undefined\";\n  var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n  var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n  var _loggersByName = {};\n  var defaultLogger = null; // Cross-browser bind equivalent that works at least back to IE6\n\n  function bindMethod(obj, methodName) {\n    var method = obj[methodName];\n\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    } else {\n      try {\n        return Function.prototype.bind.call(method, obj);\n      } catch (e) {\n        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n        return function () {\n          return Function.prototype.apply.apply(method, [obj, arguments]);\n        };\n      }\n    }\n  } // Trace() doesn't print the message in IE, so for that case we need to wrap it\n\n\n  function traceForIE() {\n    if (console.log) {\n      if (console.log.apply) {\n        console.log.apply(console, arguments);\n      } else {\n        // In old IE, native console methods themselves don't have apply().\n        Function.prototype.apply.apply(console.log, [console, arguments]);\n      }\n    }\n\n    if (console.trace) console.trace();\n  } // Build the best logging method possible for this env\n  // Wherever possible we want to bind, not wrap, to preserve stack traces\n\n\n  function realMethod(methodName) {\n    if (methodName === 'debug') {\n      methodName = 'log';\n    }\n\n    if (typeof console === undefinedType) {\n      return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n    } else if (methodName === 'trace' && isIE) {\n      return traceForIE;\n    } else if (console[methodName] !== undefined) {\n      return bindMethod(console, methodName);\n    } else if (console.log !== undefined) {\n      return bindMethod(console, 'log');\n    } else {\n      return noop;\n    }\n  } // These private functions always need `this` to be set properly\n\n\n  function replaceLoggingMethods() {\n    /*jshint validthis:true */\n    var level = this.getLevel(); // Replace the actual methods.\n\n    for (var i = 0; i < logMethods.length; i++) {\n      var methodName = logMethods[i];\n      this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n    } // Define log.log as an alias for log.debug\n\n\n    this.log = this.debug; // Return any important warnings.\n\n    if (typeof console === undefinedType && level < this.levels.SILENT) {\n      return \"No console available for logging\";\n    }\n  } // In old IE versions, the console isn't present until you first open it.\n  // We build realMethod() replacements here that regenerate logging methods\n\n\n  function enableLoggingWhenConsoleArrives(methodName) {\n    return function () {\n      if (typeof console !== undefinedType) {\n        replaceLoggingMethods.call(this);\n        this[methodName].apply(this, arguments);\n      }\n    };\n  } // By default, we use closely bound real methods wherever possible, and\n  // otherwise we wait for a console to appear, and then try again.\n\n\n  function defaultMethodFactory(methodName, _level, _loggerName) {\n    /*jshint validthis:true */\n    return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n  }\n\n  function Logger(name, factory) {\n    // Private instance variables.\n    var self = this;\n    /**\n     * The level inherited from a parent logger (or a global default). We\n     * cache this here rather than delegating to the parent so that it stays\n     * in sync with the actual logging methods that we have installed (the\n     * parent could change levels but we might not have rebuilt the loggers\n     * in this child yet).\n     * @type {number}\n     */\n\n    var inheritedLevel;\n    /**\n     * The default level for this logger, if any. If set, this overrides\n     * `inheritedLevel`.\n     * @type {number|null}\n     */\n\n    var defaultLevel;\n    /**\n     * A user-specific level for this logger. If set, this overrides\n     * `defaultLevel`.\n     * @type {number|null}\n     */\n\n    var userLevel;\n    var storageKey = \"loglevel\";\n\n    if (typeof name === \"string\") {\n      storageKey += \":\" + name;\n    } else if (typeof name === \"symbol\") {\n      storageKey = undefined;\n    }\n\n    function persistLevelIfPossible(levelNum) {\n      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n      if (typeof window === undefinedType || !storageKey) return; // Use localStorage if available\n\n      try {\n        window.localStorage[storageKey] = levelName;\n        return;\n      } catch (ignore) {} // Use session cookie as fallback\n\n\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n      } catch (ignore) {}\n    }\n\n    function getPersistedLevel() {\n      var storedLevel;\n      if (typeof window === undefinedType || !storageKey) return;\n\n      try {\n        storedLevel = window.localStorage[storageKey];\n      } catch (ignore) {} // Fallback to cookies if local storage gives us nothing\n\n\n      if (typeof storedLevel === undefinedType) {\n        try {\n          var cookie = window.document.cookie;\n          var cookieName = encodeURIComponent(storageKey);\n          var location = cookie.indexOf(cookieName + \"=\");\n\n          if (location !== -1) {\n            storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n          }\n        } catch (ignore) {}\n      } // If the stored level is not valid, treat it as if nothing was stored.\n\n\n      if (self.levels[storedLevel] === undefined) {\n        storedLevel = undefined;\n      }\n\n      return storedLevel;\n    }\n\n    function clearPersistedLevel() {\n      if (typeof window === undefinedType || !storageKey) return; // Use localStorage if available\n\n      try {\n        window.localStorage.removeItem(storageKey);\n      } catch (ignore) {} // Use session cookie as fallback\n\n\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n      } catch (ignore) {}\n    }\n\n    function normalizeLevel(input) {\n      var level = input;\n\n      if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n        level = self.levels[level.toUpperCase()];\n      }\n\n      if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n        return level;\n      } else {\n        throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n      }\n    }\n    /*\n     *\n     * Public logger API - see https://github.com/pimterry/loglevel for details\n     *\n     */\n\n\n    self.name = name;\n    self.levels = {\n      \"TRACE\": 0,\n      \"DEBUG\": 1,\n      \"INFO\": 2,\n      \"WARN\": 3,\n      \"ERROR\": 4,\n      \"SILENT\": 5\n    };\n    self.methodFactory = factory || defaultMethodFactory;\n\n    self.getLevel = function () {\n      if (userLevel != null) {\n        return userLevel;\n      } else if (defaultLevel != null) {\n        return defaultLevel;\n      } else {\n        return inheritedLevel;\n      }\n    };\n\n    self.setLevel = function (level, persist) {\n      userLevel = normalizeLevel(level);\n\n      if (persist !== false) {\n        // defaults to true\n        persistLevelIfPossible(userLevel);\n      } // NOTE: in v2, this should call rebuild(), which updates children.\n\n\n      return replaceLoggingMethods.call(self);\n    };\n\n    self.setDefaultLevel = function (level) {\n      defaultLevel = normalizeLevel(level);\n\n      if (!getPersistedLevel()) {\n        self.setLevel(level, false);\n      }\n    };\n\n    self.resetLevel = function () {\n      userLevel = null;\n      clearPersistedLevel();\n      replaceLoggingMethods.call(self);\n    };\n\n    self.enableAll = function (persist) {\n      self.setLevel(self.levels.TRACE, persist);\n    };\n\n    self.disableAll = function (persist) {\n      self.setLevel(self.levels.SILENT, persist);\n    };\n\n    self.rebuild = function () {\n      if (defaultLogger !== self) {\n        inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n      }\n\n      replaceLoggingMethods.call(self);\n\n      if (defaultLogger === self) {\n        for (var childName in _loggersByName) {\n          _loggersByName[childName].rebuild();\n        }\n      }\n    }; // Initialize all the internal levels.\n\n\n    inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n    var initialLevel = getPersistedLevel();\n\n    if (initialLevel != null) {\n      userLevel = normalizeLevel(initialLevel);\n    }\n\n    replaceLoggingMethods.call(self);\n  }\n  /*\n   *\n   * Top-level API\n   *\n   */\n\n\n  defaultLogger = new Logger();\n\n  defaultLogger.getLogger = function getLogger(name) {\n    if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n      throw new TypeError(\"You must supply a name when creating a logger.\");\n    }\n\n    var logger = _loggersByName[name];\n\n    if (!logger) {\n      logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n    }\n\n    return logger;\n  }; // Grab the current global log variable in case of overwrite\n\n\n  var _log = typeof window !== undefinedType ? window.log : undefined;\n\n  defaultLogger.noConflict = function () {\n    if (typeof window !== undefinedType && window.log === defaultLogger) {\n      window.log = _log;\n    }\n\n    return defaultLogger;\n  };\n\n  defaultLogger.getLoggers = function getLoggers() {\n    return _loggersByName;\n  }; // ES6 default export, for compatibility\n\n\n  defaultLogger['default'] = defaultLogger;\n  return defaultLogger;\n});","map":{"version":3,"sources":["C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/loglevel/lib/loglevel.js"],"names":["root","definition","define","amd","module","exports","log","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","trace","realMethod","undefined","replaceLoggingMethods","level","getLevel","i","length","methodFactory","name","debug","levels","SILENT","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","Logger","factory","self","inheritedLevel","defaultLevel","userLevel","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","cookieName","location","indexOf","exec","slice","clearPersistedLevel","removeItem","normalizeLevel","input","TypeError","setLevel","persist","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","rebuild","childName","initialLevel","getLogger","logger","_log","noConflict","getLoggers"],"mappings":"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","sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n"]},"metadata":{},"sourceType":"script"}