{"ast":null,"code":"'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\n\n\nvar listGetNode = function listGetNode(list, key, isDelete) {\n  /** @type {typeof list | NonNullable<(typeof list)['next']>} */\n  var prev = list;\n  /** @type {(typeof list)['next']} */\n\n  var curr; // eslint-disable-next-line eqeqeq\n\n  for (; (curr = prev.next) != null; prev = curr) {\n    if (curr.key === key) {\n      prev.next = curr.next;\n\n      if (!isDelete) {\n        // eslint-disable-next-line no-extra-parens\n        curr.next =\n        /** @type {NonNullable<typeof list.next>} */\n        list.next;\n        list.next = curr; // eslint-disable-line no-param-reassign\n      }\n\n      return curr;\n    }\n  }\n};\n/** @type {import('./list.d.ts').listGet} */\n\n\nvar listGet = function listGet(objects, key) {\n  if (!objects) {\n    return void undefined;\n  }\n\n  var node = listGetNode(objects, key);\n  return node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\n\n\nvar listSet = function listSet(objects, key, value) {\n  var node = listGetNode(objects, key);\n\n  if (node) {\n    node.value = value;\n  } else {\n    // Prepend the new node to the beginning of the list\n    objects.next =\n    /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */\n    {\n      // eslint-disable-line no-param-reassign, no-extra-parens\n      key: key,\n      next: objects.next,\n      value: value\n    };\n  }\n};\n/** @type {import('./list.d.ts').listHas} */\n\n\nvar listHas = function listHas(objects, key) {\n  if (!objects) {\n    return false;\n  }\n\n  return !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\n\n\nvar listDelete = function listDelete(objects, key) {\n  if (objects) {\n    return listGetNode(objects, key, true);\n  }\n};\n/** @type {import('.')} */\n\n\nmodule.exports = function getSideChannelList() {\n  /** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\n  /** @typedef {Parameters<Channel['get']>[0]} K */\n\n  /** @typedef {Parameters<Channel['set']>[1]} V */\n\n  /** @type {import('./list.d.ts').RootNode<V, K> | undefined} */\n  var $o;\n  /** @type {Channel} */\n\n  var channel = {\n    assert: function assert(key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    'delete': function _delete(key) {\n      var root = $o && $o.next;\n      var deletedNode = listDelete($o, key);\n\n      if (deletedNode && root && root === deletedNode) {\n        $o = void undefined;\n      }\n\n      return !!deletedNode;\n    },\n    get: function get(key) {\n      return listGet($o, key);\n    },\n    has: function has(key) {\n      return listHas($o, key);\n    },\n    set: function set(key, value) {\n      if (!$o) {\n        // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n        $o = {\n          next: void undefined\n        };\n      } // eslint-disable-next-line no-extra-parens\n\n\n      listSet(\n      /** @type {NonNullable<typeof $o>} */\n      $o, key, value);\n    }\n  }; // @ts-expect-error TODO: figure out why this is erroring\n\n  return channel;\n};","map":{"version":3,"sources":["C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/side-channel-list/index.js"],"names":["inspect","require","$TypeError","listGetNode","list","key","isDelete","prev","curr","next","listGet","objects","undefined","node","value","listSet","listHas","listDelete","module","exports","getSideChannelList","$o","channel","assert","has","root","deletedNode","get","set"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\nvar listGetNode = function (list, key, isDelete) {\n\t/** @type {typeof list | NonNullable<(typeof list)['next']>} */\n\tvar prev = list;\n\t/** @type {(typeof list)['next']} */\n\tvar curr;\n\t// eslint-disable-next-line eqeqeq\n\tfor (; (curr = prev.next) != null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tif (!isDelete) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tcurr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\n/** @type {import('./list.d.ts').listGet} */\nvar listGet = function (objects, key) {\n\tif (!objects) {\n\t\treturn void undefined;\n\t}\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t});\n\t}\n};\n/** @type {import('./list.d.ts').listHas} */\nvar listHas = function (objects, key) {\n\tif (!objects) {\n\t\treturn false;\n\t}\n\treturn !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\nvar listDelete = function (objects, key) {\n\tif (objects) {\n\t\treturn listGetNode(objects, key, true);\n\t}\n};\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannelList() {\n\t/** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tvar root = $o && $o.next;\n\t\t\tvar deletedNode = listDelete($o, key);\n\t\t\tif (deletedNode && root && root === deletedNode) {\n\t\t\t\t$o = void undefined;\n\t\t\t}\n\t\t\treturn !!deletedNode;\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn listGet($o, key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn listHas($o, key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$o) {\n\t\t\t\t// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n\t\t\t\t$o = {\n\t\t\t\t\tnext: void undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tlistSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n"]},"metadata":{},"sourceType":"script"}