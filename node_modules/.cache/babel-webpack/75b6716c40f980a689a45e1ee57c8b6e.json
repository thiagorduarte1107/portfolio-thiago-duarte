{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bound');\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n\nvar $Map = GetIntrinsic('%Map%', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */\n\nvar $mapGet = callBound('Map.prototype.get', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */\n\nvar $mapSet = callBound('Map.prototype.set', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\n\nvar $mapHas = callBound('Map.prototype.has', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\n\nvar $mapDelete = callBound('Map.prototype.delete', true);\n/** @type {<K, V>(thisArg: Map<K, V>) => number} */\n\nvar $mapSize = callBound('Map.prototype.size', true);\n/** @type {import('.')} */\n\nmodule.exports = !!$Map &&\n/** @type {Exclude<import('.'), false>} */\nfunction getSideChannelMap() {\n  /** @typedef {ReturnType<typeof getSideChannelMap>} Channel */\n\n  /** @typedef {Parameters<Channel['get']>[0]} K */\n\n  /** @typedef {Parameters<Channel['set']>[1]} V */\n\n  /** @type {Map<K, V> | undefined} */\n  var $m;\n  /** @type {Channel} */\n\n  var channel = {\n    assert: function assert(key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    'delete': function _delete(key) {\n      if ($m) {\n        var result = $mapDelete($m, key);\n\n        if ($mapSize($m) === 0) {\n          $m = void undefined;\n        }\n\n        return result;\n      }\n\n      return false;\n    },\n    get: function get(key) {\n      // eslint-disable-line consistent-return\n      if ($m) {\n        return $mapGet($m, key);\n      }\n    },\n    has: function has(key) {\n      if ($m) {\n        return $mapHas($m, key);\n      }\n\n      return false;\n    },\n    set: function set(key, value) {\n      if (!$m) {\n        // @ts-expect-error TS can't handle narrowing a variable inside a closure\n        $m = new $Map();\n      }\n\n      $mapSet($m, key, value);\n    }\n  }; // @ts-expect-error TODO: figure out why TS is erroring here\n\n  return channel;\n};","map":{"version":3,"sources":["C:/Users/Thiago-510/CascadeProjects/portfolio-thiago-duarte/node_modules/side-channel-map/index.js"],"names":["GetIntrinsic","require","callBound","inspect","$TypeError","$Map","$mapGet","$mapSet","$mapHas","$mapDelete","$mapSize","module","exports","getSideChannelMap","$m","channel","assert","key","has","result","undefined","get","set","value"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,YAAD,CAAvB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAIG,UAAU,GAAGH,OAAO,CAAC,gBAAD,CAAxB;;AACA,IAAII,IAAI,GAAGL,YAAY,CAAC,OAAD,EAAU,IAAV,CAAvB;AAEA;;AACA,IAAIM,OAAO,GAAGJ,SAAS,CAAC,mBAAD,EAAsB,IAAtB,CAAvB;AACA;;AACA,IAAIK,OAAO,GAAGL,SAAS,CAAC,mBAAD,EAAsB,IAAtB,CAAvB;AACA;;AACA,IAAIM,OAAO,GAAGN,SAAS,CAAC,mBAAD,EAAsB,IAAtB,CAAvB;AACA;;AACA,IAAIO,UAAU,GAAGP,SAAS,CAAC,sBAAD,EAAyB,IAAzB,CAA1B;AACA;;AACA,IAAIQ,QAAQ,GAAGR,SAAS,CAAC,oBAAD,EAAuB,IAAvB,CAAxB;AAEA;;AACAS,MAAM,CAACC,OAAP,GAAiB,CAAC,CAACP,IAAF;AAAU;AAA2C,SAASQ,iBAAT,GAA6B;AAClG;;AACA;;AACA;;AAEA;AAAqC,MAAIC,EAAJ;AAErC;;AACA,MAAIC,OAAO,GAAG;AACbC,IAAAA,MAAM,EAAE,SAARA,MAAQ,CAAUC,GAAV,EAAe;AACtB,UAAI,CAACF,OAAO,CAACG,GAAR,CAAYD,GAAZ,CAAL,EAAuB;AACtB,cAAM,IAAIb,UAAJ,CAAe,mCAAmCD,OAAO,CAACc,GAAD,CAAzD,CAAN;AACA;AACD,KALY;AAMb,cAAU,SAAV,OAAU,CAAUA,GAAV,EAAe;AACxB,UAAIH,EAAJ,EAAQ;AACP,YAAIK,MAAM,GAAGV,UAAU,CAACK,EAAD,EAAKG,GAAL,CAAvB;;AACA,YAAIP,QAAQ,CAACI,EAAD,CAAR,KAAiB,CAArB,EAAwB;AACvBA,UAAAA,EAAE,GAAG,KAAKM,SAAV;AACA;;AACD,eAAOD,MAAP;AACA;;AACD,aAAO,KAAP;AACA,KAfY;AAgBbE,IAAAA,GAAG,EAAE,SAALA,GAAK,CAAUJ,GAAV,EAAe;AAAE;AACrB,UAAIH,EAAJ,EAAQ;AACP,eAAOR,OAAO,CAACQ,EAAD,EAAKG,GAAL,CAAd;AACA;AACD,KApBY;AAqBbC,IAAAA,GAAG,EAAE,SAALA,GAAK,CAAUD,GAAV,EAAe;AACnB,UAAIH,EAAJ,EAAQ;AACP,eAAON,OAAO,CAACM,EAAD,EAAKG,GAAL,CAAd;AACA;;AACD,aAAO,KAAP;AACA,KA1BY;AA2BbK,IAAAA,GAAG,EAAE,SAALA,GAAK,CAAUL,GAAV,EAAeM,KAAf,EAAsB;AAC1B,UAAI,CAACT,EAAL,EAAS;AACR;AACAA,QAAAA,EAAE,GAAG,IAAIT,IAAJ,EAAL;AACA;;AACDE,MAAAA,OAAO,CAACO,EAAD,EAAKG,GAAL,EAAUM,KAAV,CAAP;AACA;AAjCY,GAAd,CARkG,CA4ClG;;AACA,SAAOR,OAAP;AACA,CA9CD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\nvar $Map = GetIntrinsic('%Map%', true);\n\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */\nvar $mapGet = callBound('Map.prototype.get', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */\nvar $mapSet = callBound('Map.prototype.set', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapHas = callBound('Map.prototype.has', true);\n/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */\nvar $mapDelete = callBound('Map.prototype.delete', true);\n/** @type {<K, V>(thisArg: Map<K, V>) => number} */\nvar $mapSize = callBound('Map.prototype.size', true);\n\n/** @type {import('.')} */\nmodule.exports = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {\n\t/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {Map<K, V> | undefined} */ var $m;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tif ($m) {\n\t\t\t\tvar result = $mapDelete($m, key);\n\t\t\t\tif ($mapSize($m) === 0) {\n\t\t\t\t\t$m = void undefined;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($m) {\n\t\t\t\treturn $mapGet($m, key);\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($m) {\n\t\t\t\treturn $mapHas($m, key);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$m) {\n\t\t\t\t// @ts-expect-error TS can't handle narrowing a variable inside a closure\n\t\t\t\t$m = new $Map();\n\t\t\t}\n\t\t\t$mapSet($m, key, value);\n\t\t}\n\t};\n\n\t// @ts-expect-error TODO: figure out why TS is erroring here\n\treturn channel;\n};\n"]},"metadata":{},"sourceType":"script"}